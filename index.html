<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Keyword: Master English</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0284c7">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Keyword">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <link rel="icon" href="/icons/icon-192x192.png" type="image/png">
  <script src="words_db_en.js"></script>
  <script src="stories_db_en.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; overscroll-behavior-y: contain; }
    .card { transform-style: preserve-3d; transition: transform 0.6s; }
    .card.is-flipped { transform: rotateY(180deg); }
    .card-face { position: absolute; width: 100%; height: 100%; backface-visibility: hidden; -webkit-backface-visibility: hidden; transform: translateZ(0); }
    .card-face-back { transform: rotateY(180deg) translateZ(1px); }
    .btn-difficulty { transition: all 0.2s ease-in-out; }
    .btn-difficulty:hover { transform: translateY(-2px); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
    .modal { transition: opacity 0.3s ease; }
    .modal-content { transition: transform 0.3s ease; }
    #header-image-container:hover #upload-header-btn, .card-face-front:hover #upload-global-bg-btn { opacity: 1; }
  </style>
</head>
<body class="bg-slate-50 text-slate-800 flex items-center justify-center min-h-screen">
  <input type="file" id="image-upload-input" class="hidden" accept="image/*">
  <input type="file" id="header-upload-input" class="hidden" accept="image/*">
  <input type="file" id="story-upload-input" class="hidden" accept=".txt">
  <input type="file" id="global-bg-upload-input" class="hidden" accept="image/*">
  <input type="file" id="story-bg-upload-input" class="hidden" accept="image/*">

  <div id="app" class="w-full max-w-md mx-auto p-4 sm:p-6">
    <header class="text-center mb-4">
      <div id="header-image-container" class="relative w-full aspect-[3.5/1] bg-slate-200 rounded-lg mb-4 overflow-hidden group">
        <img id="header-image" src="images/default-header.jpg" alt="Header" class="w-full h-full object-cover">
        <button id="upload-header-btn" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white opacity-0 group-hover:opacity-100 transition-opacity">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
          <span class="ml-2">Change Photo</span>
        </button>
      </div>
      <h1 class="text-3xl sm:text-4xl font-bold text-sky-600">Keyword</h1>
      <p class="text-slate-500 mt-1">Master English, word by word!</p>
    </header>

    <nav class="relative flex justify-center items-center space-x-2 sm:space-x-4 mb-6 border-b pb-4">
      <button id="show-auth-btn" title="User Account" class="p-3 bg-slate-100 rounded-full text-slate-500 hover:bg-sky-100 hover:text-sky-600 transition-colors">
        <svg id="auth-icon-user" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
        <svg id="auth-icon-logout" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
      </button>
      <button id="show-decks-btn" title="Decks" class="p-3 bg-slate-100 rounded-full text-slate-500 hover:bg-sky-100 hover:text-sky-600 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 16V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2z"></path><path d="M20 12v4H4v-4"></path><path d="M4 8h16"></path></svg>
      </button>
      <button id="show-learned-words-btn" title="Learned Words" class="p-3 bg-slate-100 rounded-full text-slate-500 hover:bg-sky-100 hover:text-sky-600 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 11 3 3L22 4"></path><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>
      </button>
      <button id="show-stats-btn" title="Progress Chart" class="p-3 bg-slate-100 rounded-full text-slate-500 hover:bg-sky-100 hover:text-sky-600 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>
      </button>
      <button id="show-stories-btn" title="Story Library" class="p-3 bg-slate-100 rounded-full text-slate-500 hover:bg-sky-100 hover:text-sky-600 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1-3-3h7z"></path></svg>
      </button>
      <button id="show-review-btn" title="Review Session" class="p-3 bg-slate-100 rounded-full text-slate-500 hover:bg-sky-100 hover:text-sky-600 transition-colors">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 8"/><path d="M21 22v-6h-6"/><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"/></svg>
      </button>
    </nav>
    
    <section id="auth-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Twoje Konto</h2>
      <div id="auth-state-logged-in" class="hidden">
        <p class="text-lg mb-2">Witaj, <span id="user-email" class="font-medium text-sky-600"></span>!</p>
        <button id="logout-btn" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors">Wyloguj</button>
      </div>
      <div id="auth-state-logged-out">
        <div class="mb-4">
          <input type="email" id="auth-email" placeholder="Email" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
        </div>
        <div class="mb-4">
          <input type="password" id="auth-password" placeholder="Hasło" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
        </div>
        <div class="flex space-x-2">
          <button id="signup-btn" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors flex-grow">Zarejestruj się</button>
          <button id="login-btn" class="bg-emerald-500 text-white px-4 py-2 rounded-lg hover:bg-emerald-600 transition-colors flex-grow">Zaloguj</button>
        </div>
        <p id="auth-message" class="text-sm text-red-500 mt-2 hidden"></p>
      </div>
    </section>

    <section id="decks-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Twoje Talie</h2>
      <div id="decks-list" class="space-y-3 mb-6">
      </div>
      <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
        <input type="text" id="new-deck-name" placeholder="Nazwa nowej talii" class="w-full sm:flex-grow p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
        <button id="add-deck-btn" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors whitespace-nowrap">Dodaj talię</button>
      </div>
      <button id="import-words-btn" class="mt-4 w-full bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 transition-colors">Importuj słówka z pliku</button>
    </section>

    <section id="word-management-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Słówka w Talii: <span id="active-deck-name" class="font-bold"></span></h2>
      <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
        <input type="text" id="english-input" placeholder="Słówko angielskie" class="flex-grow p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
        <input type="text" id="polish-input" placeholder="Tłumaczenie polskie" class="flex-grow p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
      </div>
      <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2 mb-4">
        <input type="text" id="example-en-input" placeholder="Przykładowe zdanie (ang.)" class="flex-grow p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
        <input type="text" id="example-pl-input" placeholder="Przykładowe zdanie (pol.)" class="flex-grow p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
      </div>
      <div class="flex items-center space-x-2 mb-4">
        <img id="word-image-preview" src="" alt="Podgląd obrazka" class="w-20 h-20 object-cover rounded-lg border border-slate-300 hidden">
        <button id="add-image-btn" class="bg-yellow-500 text-white px-4 py-2 rounded-lg hover:bg-yellow-600 transition-colors">Dodaj/Zmień obrazek</button>
        <button id="remove-image-btn" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors hidden">Usuń obrazek</button>
      </div>
      <button id="add-word-btn" class="w-full bg-emerald-500 text-white px-4 py-2 rounded-lg hover:bg-emerald-600 transition-colors mb-6">Dodaj słówko</button>
      
      <div id="word-list" class="space-y-3">
      </div>
      <button id="back-to-decks-btn" class="mt-6 w-full bg-slate-300 text-slate-800 px-4 py-2 rounded-lg hover:bg-slate-400 transition-colors">Powrót do talii</button>
    </section>

    <section id="review-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Sesja Powtórkowa</h2>
      <div id="review-controls" class="mb-4">
        <button id="start-review-btn" class="w-full bg-sky-500 text-white px-6 py-3 rounded-lg text-lg font-bold hover:bg-sky-600 transition-colors">
          Rozpocznij naukę
        </button>
      </div>
      
      <div id="card-container" class="relative w-full aspect-video bg-white rounded-lg shadow-lg flex items-center justify-center mb-6 overflow-hidden">
        <div id="flashcard" class="card w-full h-full relative">
          <div id="card-front" class="card-face card-face-front bg-white p-6 rounded-lg text-center flex flex-col justify-center items-center group">
            <h3 id="card-english" class="text-4xl font-bold text-sky-800 break-words max-w-full"></h3>
            <p id="card-example-en" class="text-slate-600 mt-2 text-lg italic hidden break-words max-w-full"></p>
            <img id="card-image" src="" alt="Obrazek do słówka" class="mt-4 max-h-32 object-contain rounded-lg shadow hidden">
            <button id="speak-english-btn" class="absolute bottom-4 right-4 p-2 rounded-full bg-sky-100 text-sky-600 hover:bg-sky-200 transition-colors">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14M22.42 1.58a15 15 0 0 1 0 20.84"></path></svg>
            </button>
            <button id="upload-global-bg-btn" class="absolute top-4 left-4 p-2 rounded-full bg-black bg-opacity-30 text-white opacity-0 group-hover:opacity-100 transition-opacity">
              <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
            </button>
          </div>
          <div id="card-back" class="card-face card-face-back bg-sky-50 p-6 rounded-lg text-center flex flex-col justify-center items-center">
            <h3 id="card-polish" class="text-4xl font-bold text-sky-800 break-words max-w-full"></h3>
            <p id="card-example-pl" class="text-slate-600 mt-2 text-lg italic hidden break-words max-w-full"></p>
            <button id="speak-polish-btn" class="absolute bottom-4 right-4 p-2 rounded-full bg-sky-100 text-sky-600 hover:bg-sky-200 transition-colors">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14M22.42 1.58a15 15 0 0 1 0 20.84"></path></svg>
            </button>
          </div>
        </div>
      </div>
      
      <div id="difficulty-buttons" class="grid grid-cols-3 gap-3">
        <button id="again-btn" class="btn-difficulty bg-red-400 text-white px-4 py-2 rounded-lg text-lg font-semibold hover:bg-red-500">Trudno (<span id="again-interval">1m</span>)</button>
        <button id="hard-btn" class="btn-difficulty bg-orange-400 text-white px-4 py-2 rounded-lg text-lg font-semibold hover:bg-orange-500">Średnio (<span id="hard-interval">10m</span>)</button>
        <button id="good-btn" class="btn-difficulty bg-green-500 text-white px-4 py-2 rounded-lg text-lg font-semibold hover:bg-green-600">Łatwo (<span id="good-interval">1d</span>)</button>
      </div>

      <p id="review-status" class="text-center text-slate-600 mt-4 hidden"></p>
      <button id="finish-review-btn" class="w-full bg-slate-300 text-slate-800 px-4 py-2 rounded-lg hover:bg-slate-400 transition-colors mt-4 hidden">Zakończ sesję</button>
    </section>

    <section id="learned-words-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Opanowane słówka</h2>
      <div id="learned-words-list" class="space-y-3">
      </div>
    </section>

    <section id="stats-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Statystyki Postępów</h2>
      <div class="bg-white p-4 rounded-lg shadow-lg">
        <canvas id="progressChart"></canvas>
      </div>
      <div class="mt-6 grid grid-cols-1 sm:grid-cols-2 gap-4 text-lg">
        <p class="text-slate-700"><span class="font-bold text-sky-600" id="total-words-count">0</span> słówek w systemie</p>
        <p class="text-slate-700"><span class="font-bold text-emerald-600" id="learned-words-count">0</span> opanowanych</p>
        <p class="text-slate-700"><span class="font-bold text-orange-600" id="to-review-count">0</span> do powtórki dziś</p>
        <p class="text-slate-700"><span class="font-bold text-indigo-600" id="new-words-today-count">0</span> nowych dziś</p>
      </div>
    </section>

    <section id="stories-section" class="hidden">
      <h2 class="text-2xl font-semibold mb-4 text-sky-700">Biblioteka Historii</h2>
      <div id="stories-list" class="space-y-3 mb-6">
      </div>
      <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
        <input type="text" id="new-story-title" placeholder="Tytuł nowej historii" class="w-full sm:flex-grow p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
        <button id="add-story-btn" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors whitespace-nowrap">Dodaj historię</button>
      </div>
      <button id="import-story-file-btn" class="mt-4 w-full bg-indigo-500 text-white px-4 py-2 rounded-lg hover:bg-indigo-600 transition-colors">Importuj historię z pliku</button>
    </section>

    <section id="story-viewer-section" class="fixed inset-0 bg-white z-50 p-4 sm:p-6 flex flex-col hidden">
      <div class="flex items-center justify-between mb-4">
        <button id="back-to-stories-btn" class="bg-slate-300 text-slate-800 px-4 py-2 rounded-lg hover:bg-slate-400 transition-colors flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1"><polyline points="15 18 9 12 15 6"></polyline></svg>
          Wróć
        </button>
        <h2 id="story-viewer-title" class="text-2xl font-semibold text-sky-700 mx-auto"></h2>
        <button id="upload-story-bg-btn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
          Tło
        </button>
      </div>
      <div id="story-content" class="flex-grow overflow-y-auto bg-slate-50 p-4 rounded-lg shadow-inner text-lg leading-relaxed story-text-content">
      </div>
    </section>
  </div>

  <div id="modal-container" class="modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
    <div class="modal-content bg-white rounded-lg shadow-xl p-6 w-full max-w-md transform translate-y-4">
      <h3 id="modal-title" class="text-xl font-bold mb-4 text-sky-700"></h3>
      <div id="modal-body">
      </div>
      <div class="flex justify-end space-x-2 mt-6">
        <button id="modal-cancel-btn" class="bg-slate-300 text-slate-800 px-4 py-2 rounded-lg hover:bg-slate-400 transition-colors">Anuluj</button>
        <button id="modal-confirm-btn" class="bg-sky-500 text-white px-4 py-2 rounded-lg hover:bg-sky-600 transition-colors">Potwierdź</button>
      </div>
    </div>
  </div>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js').then(registration => {
          console.log('ServiceWorker registered: ', registration);
        }).catch(error => {
          console.log('ServiceWorker registration failed: ', error);
        });
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      // --- SUPABASE & APP CONFIGURATION ---
      const SUPABASE_URL = 'https://elneujplpdoruvrvzvzd.supabase.co';
      const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVsbmV1anBscGRvcnV2cnZ6dnpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjYyOTI3NjYsImV4cCI6MjA0MTg2ODc2Nn0.YIJYmt8KeiXH0iFS_Pk6ErIkyKZpPDsi29G83VItjCc';
      const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
      console.log('Supabase client initialized successfully.');

      const ENGLISH_ACCENT = 'en-GB';
      // CONFIG: wyłączenie limitów dziennych
      const REVIEW_IGNORE_DATE = true; // true => pokaż wszystkie słowa do powtórki, niezależnie od daty
      const DAILY_NEW_LIMIT = Infinity; // Infinity => brak limitu nowych słów dziennie

      // --- IndexedDB Setup ---
      let db;
      const DB_NAME = 'flashcard-app';
      const DB_VERSION = 3; // Zwiększ wersję, aby IndexedDB wymusiło migrację

      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onupgradeneeded = (event) => {
        db = event.target.result;
        console.log('IndexedDB upgrade needed. Old version:', event.oldVersion, 'New version:', event.newVersion);

        // Usuń stare obiekty, jeśli istnieją, aby zapewnić czysty start
        if (db.objectStoreNames.contains('app-data')) {
            db.deleteObjectStore('app-data');
        }
        if (db.objectStoreNames.contains('decks')) {
            db.deleteObjectStore('decks');
        }
        if (db.objectStoreNames.contains('words')) {
            db.deleteObjectStore('words');
        }
        if (db.objectStoreNames.contains('stories')) {
            db.deleteObjectStore('stories');
        }
        if (db.objectStoreNames.contains('story-progress')) {
            db.deleteObjectStore('story-progress');
        }

        // Tworzenie nowych magazynów obiektów
        const appDataStore = db.createObjectStore('app-data', { keyPath: 'key' });

        const decksStore = db.createObjectStore('decks', { keyPath: 'id' });
        decksStore.createIndex('user_id', 'user_id', { unique: false }); // Indeks dla user_id

        const wordsStore = db.createObjectStore('words', { keyPath: 'id' });
        wordsStore.createIndex('deckId', 'deckId', { unique: false });
        wordsStore.createIndex('userId', 'userId', { unique: false });

        const storiesStore = db.createObjectStore('stories', { keyPath: 'id' });
        storiesStore.createIndex('user_id', 'user_id', { unique: false });

        const storyProgressStore = db.createObjectStore('story-progress', { keyPath: ['story_id', 'user_id'] });
      };

      request.onsuccess = (event) => {
        db = event.target.result;
        console.log('IndexedDB opened successfully');
        init();
      };

      request.onerror = (event) => {
        console.error('IndexedDB error:', event.target.errorCode);
      };

      function getTransaction(storeName, mode = 'readwrite') {
        return db.transaction(storeName, mode).objectStore(storeName);
      }

      function idbRequest(request) {
        return new Promise((resolve, reject) => {
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error);
        });
      }

      // --- App Data (Local Storage / IndexedDB) ---
      async function getAppData(key) {
        try {
          const store = getTransaction('app-data', 'readonly');
          const data = await idbRequest(store.get(key));
          return data ? data.value : null;
        } catch (e) {
          console.error("Error getting app data from IndexedDB:", e);
          return null;
        }
      }

      async function setAppData(key, value) {
        try {
          const store = getTransaction('app-data');
          await idbRequest(store.put({ key, value }));
        } catch (e) {
          console.error("Error setting app data in IndexedDB:", e);
        }
      }

      // --- STATE & DOM ELEMENTS ---
      let user = null;
      let activeDeckId = null;
      let words = [];
      let decks = [];
      let stories = [];
      let currentCardIndex = 0;
      let currentCard = null;
      let isCardFlipped = false;
      let reviewQueue = [];
      let chartInstance = null;
      let activeStory = null;
      let currentStoryParagraphIndex = 0;
      let storyProgress = {};

      const authSection = document.getElementById('auth-section');
      const authStateLoggedIn = document.getElementById('auth-state-logged-in');
      const authStateLoggedOut = document.getElementById('auth-state-logged-out');
      const userEmailSpan = document.getElementById('user-email');
      const authEmailInput = document.getElementById('auth-email');
      const authPasswordInput = document.getElementById('auth-password');
      const authMessage = document.getElementById('auth-message');
      const signupBtn = document.getElementById('signup-btn');
      const loginBtn = document.getElementById('login-btn');
      const logoutBtn = document.getElementById('logout-btn');
      const authIconUser = document.getElementById('auth-icon-user');
      const authIconLogout = document.getElementById('auth-icon-logout');

      const sections = document.querySelectorAll('section');
      const navButtons = document.querySelectorAll('nav button');
      const decksList = document.getElementById('decks-list');
      const newDeckNameInput = document.getElementById('new-deck-name');
      const addDeckBtn = document.getElementById('add-deck-btn');
      const importWordsBtn = document.getElementById('import-words-btn');
      const activeDeckNameSpan = document.getElementById('active-deck-name');
      const englishInput = document.getElementById('english-input');
      const polishInput = document.getElementById('polish-input');
      const exampleEnInput = document.getElementById('example-en-input');
      const examplePlInput = document.getElementById('example-pl-input');
      const wordImagePreview = document.getElementById('word-image-preview');
      const addImageBtn = document.getElementById('add-image-btn');
      const removeImageBtn = document.getElementById('remove-image-btn');
      const addWordBtn = document.getElementById('add-word-btn');
      const wordList = document.getElementById('word-list');
      const imageUploadInput = document.getElementById('image-upload-input');
      const headerUploadInput = document.getElementById('header-upload-input');
      const globalBgUploadInput = document.getElementById('global-bg-upload-input');
      const storyUploadInput = document.getElementById('story-upload-input');
      const storyBgUploadInput = document.getElementById('story-bg-upload-input');
      const uploadHeaderBtn = document.getElementById('upload-header-btn');
      const headerImage = document.getElementById('header-image');
      const uploadGlobalBgBtn = document.getElementById('upload-global-bg-btn');
      const modalContainer = document.getElementById('modal-container');
      const modalTitle = document.getElementById('modal-title');
      const modalBody = document.getElementById('modal-body');
      const modalContent = document.querySelector('.modal-content'); // Dodane
      const modalConfirmBtn = document.getElementById('modal-confirm-btn');
      const modalCancelBtn = document.getElementById('modal-cancel-btn');
      const startReviewBtn = document.getElementById('start-review-btn');
      const flashcard = document.getElementById('flashcard');
      const cardFront = document.getElementById('card-front');
      const cardBack = document.getElementById('card-back');
      const cardEnglish = document.getElementById('card-english');
      const cardPolish = document.getElementById('card-polish');
      const cardExampleEn = document.getElementById('card-example-en');
      const cardExamplePl = document.getElementById('card-example-pl');
      const cardImage = document.getElementById('card-image');
      const speakEnglishBtn = document.getElementById('speak-english-btn');
      const speakPolishBtn = document.getElementById('speak-polish-btn');
      const difficultyButtons = document.getElementById('difficulty-buttons');
      const againBtn = document.getElementById('again-btn');
      const hardBtn = document.getElementById('hard-btn');
      const goodBtn = document.getElementById('good-btn');
      const againIntervalSpan = document.getElementById('again-interval');
      const hardIntervalSpan = document.getElementById('hard-interval');
      const goodIntervalSpan = document.getElementById('good-interval');
      const reviewStatus = document.getElementById('review-status');
      const finishReviewBtn = document.getElementById('finish-review-btn');
      const learnedWordsList = document.getElementById('learned-words-list');
      const progressChartCtx = document.getElementById('progressChart').getContext('2d');
      const totalWordsCount = document.getElementById('total-words-count');
      const learnedWordsCount = document.getElementById('learned-words-count');
      const toReviewCount = document.getElementById('to-review-count');
      const newWordsTodayCount = document.getElementById('new-words-today-count');
      const storiesList = document.getElementById('stories-list');
      const newStoryTitleInput = document.getElementById('new-story-title');
      const addStoryBtn = document.getElementById('add-story-btn');
      const importStoryFileBtn = document.getElementById('import-story-file-btn');
      const storyViewerSection = document.getElementById('story-viewer-section');
      const storyViewerTitle = document.getElementById('story-viewer-title');
      const storyContentDiv = document.getElementById('story-content');
      const uploadStoryBgBtn = document.getElementById('upload-story-bg-btn');

      let currentWordImage = null;
      let activeImageTarget = null;
      let activeImageWordId = null;
      
      // --- Auth ---
      supabaseClient.auth.onAuthStateChange((event, session) => {
        console.log('Auth state change:', event, session);
        user = session?.user || null;
        updateAuthUI();
        if (event === 'SIGNED_IN') {
          init(); 
        } else if (event === 'SIGNED_OUT') {
          activeDeckId = null;
          words = [];
          decks = [];
          stories = [];
          reviewQueue = [];
          user = null;
          showSection('auth-section');
          clearUserDataFromIndexedDB();
        }
      });

      async function clearUserDataFromIndexedDB() {
          const tx = db.transaction(['decks', 'words', 'stories', 'story-progress'], 'readwrite');
          await Promise.all([
              idbRequest(tx.objectStore('decks').clear()),
              idbRequest(tx.objectStore('words').clear()),
              idbRequest(tx.objectStore('stories').clear()),
              idbRequest(tx.objectStore('story-progress').clear())
          ]);
          // await tx.complete; // This line might be redundant with Promise.all
          console.log('User-specific IndexedDB data cleared.');
      }

      function updateAuthUI() {
        if (user) {
          userEmailSpan.textContent = user.email;
          authStateLoggedIn.classList.remove('hidden');
          authStateLoggedOut.classList.add('hidden');
          authIconUser.classList.add('hidden');
          authIconLogout.classList.remove('hidden');
        } else {
          authStateLoggedIn.classList.add('hidden');
          authStateLoggedOut.classList.remove('hidden');
          authIconUser.classList.remove('hidden');
          authIconLogout.classList.add('hidden');
          authEmailInput.value = '';
          authPasswordInput.value = '';
          authMessage.textContent = '';
          authMessage.classList.add('hidden');
        }
      }

      async function signUp() {
        const email = authEmailInput.value;
        const password = authPasswordInput.value;
        if (!email || !password) {
          displayAuthMessage('Wprowadź email i hasło.');
          return;
        }
        const { error } = await supabaseClient.auth.signUp({ email, password });
        if (error) {
          displayAuthMessage(error.message);
        } else {
          displayAuthMessage('Sprawdź swoją skrzynkę pocztową, aby potwierdzić rejestrację.', 'text-green-500');
        }
      }

      async function signIn() {
        const email = authEmailInput.value;
        const password = authPasswordInput.value;
        if (!email || !password) {
          displayAuthMessage('Wprowadź email i hasło.');
          return;
        }
        const { error } = await supabaseClient.auth.signInWithPassword({ email, password });
        if (error) {
          displayAuthMessage(error.message);
        }
      }

      async function signOut() {
        const { error } = await supabaseClient.auth.signOut();
        if (error) {
          console.error('Logout error:', error.message);
        }
      }

      function displayAuthMessage(message, colorClass = 'text-red-500') {
        authMessage.textContent = message;
        authMessage.className = `text-sm mt-2 ${colorClass}`;
        authMessage.classList.remove('hidden');
      }

      signupBtn.addEventListener('click', signUp);
      loginBtn.addEventListener('click', signIn);
      logoutBtn.addEventListener('click', signOut);

      // --- UI Management ---
      function showSection(id) {
        sections.forEach(section => {
          if (!section.classList.contains('fixed')) { // Don't hide fixed sections like story viewer unless intended
             section.classList.add('hidden');
          }
        });
        if (id === 'story-viewer-section') {
          storyViewerSection.classList.remove('hidden');
        } else {
          storyViewerSection.classList.add('hidden');
          document.getElementById(id).classList.remove('hidden');
        }

        navButtons.forEach(btn => {
          btn.classList.remove('bg-sky-100', 'text-sky-600');
          btn.classList.add('bg-slate-100', 'text-slate-500');
        });
        const activeNavBtn = document.getElementById(`show-${id.replace('-section', '')}-btn`);
        if (activeNavBtn) {
          activeNavBtn.classList.add('bg-sky-100', 'text-sky-600');
          activeNavBtn.classList.remove('bg-slate-100', 'text-slate-500');
        }
        
        if (id === 'auth-section') {
            document.getElementById('show-auth-btn').classList.add('bg-sky-100', 'text-sky-600');
            document.getElementById('show-auth-btn').classList.remove('bg-slate-100', 'text-slate-500');
        }
      }

      document.getElementById('show-auth-btn').addEventListener('click', () => showSection('auth-section'));
      document.getElementById('show-decks-btn').addEventListener('click', () => showSection('decks-section'));
      document.getElementById('show-learned-words-btn').addEventListener('click', () => showSection('learned-words-section'));
      document.getElementById('show-stats-btn').addEventListener('click', () => showSection('stats-section'));
      document.getElementById('show-stories-btn').addEventListener('click', () => showSection('stories-section'));
      document.getElementById('show-review-btn').addEventListener('click', () => showSection('review-section'));
      document.getElementById('back-to-decks-btn').addEventListener('click', () => showSection('decks-section'));
      document.getElementById('back-to-stories-btn').addEventListener('click', () => showSection('stories-section'));

      // --- ID Normalization Helper ---
      function normalizeId(id) {
          if (typeof id === 'number') return id;
          if (typeof id === 'string' && !isNaN(parseInt(id, 10))) return parseInt(id, 10);
          return id;
      }

      // --- Decks ---
      async function getCloudDecks() {
        if (!user) return [];
        const { data, error } = await supabaseClient
          .from('decks')
          .select('*')
          .eq('user_id', user.id)
          .order('name', { ascending: true });
        if (error) {
          console.error("Error fetching decks from Supabase:", error);
          return [];
        }
        return data.map(d => ({ id: normalizeId(d.id), user_id: d.user_id, name: d.name, is_public: d.is_public, created_at: d.created_at }));
      }

      async function renderDecksList() {
        decksList.innerHTML = '';
        if (user) {
            decks = await getCloudDecks();
        } else {
            decks = [];
            showSection('auth-section');
            return;
        }

        if (decks.length === 0) {
          decksList.innerHTML = '<p class="text-slate-500 text-center">Brak talii. Dodaj nową talię!</p>';
          document.getElementById('word-management-section').classList.add('hidden');
          activeDeckId = null;
          await setAppData('activeDeckId', null);
          return;
        }

        activeDeckId = normalizeId(await getAppData('activeDeckId'));
        const deckExists = decks.some(d => normalizeId(d.id) === activeDeckId);
        
        if (!activeDeckId || !deckExists) {
            activeDeckId = normalizeId(decks[0].id);
            await setAppData('activeDeckId', activeDeckId);
        }

        for (const deck of decks) {
          const deckElement = document.createElement('div');
          deckElement.className = 'bg-white p-4 rounded-lg shadow-sm flex items-center justify-between';
          deckElement.innerHTML = `
            <span class="text-lg font-medium text-sky-700 cursor-pointer deck-name" data-id="${deck.id}">${deck.name}</span>
            <div class="flex space-x-2">
              <button class="edit-deck-btn text-slate-500 hover:text-sky-600" data-id="${deck.id}">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
              </button>
              <button class="delete-deck-btn text-red-500 hover:text-red-600" data-id="${deck.id}">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
              </button>
            </div>
          `;
          decksList.appendChild(deckElement);
        }
        
        document.querySelectorAll('.deck-name').forEach(el => {
            el.addEventListener('click', async (e) => {
                activeDeckId = normalizeId(e.target.dataset.id);
                await setAppData('activeDeckId', activeDeckId);
                await setActiveDeck(activeDeckId);
                showSection('word-management-section');
            });
        });

        document.querySelectorAll('.edit-deck-btn').forEach(el => {
            el.addEventListener('click', async (e) => {
                const deckId = normalizeId(e.currentTarget.dataset.id);
                const deck = decks.find(d => normalizeId(d.id) === deckId);
                if (deck) {
                    const newName = prompt("Podaj nową nazwę dla talii:", deck.name);
                    if (newName && newName !== deck.name) {
                        await updateDeck(deckId, newName);
                        await renderDecksList();
                    }
                }
            });
        });

        document.querySelectorAll('.delete-deck-btn').forEach(el => {
            el.addEventListener('click', async (e) => {
                const deckId = normalizeId(e.currentTarget.dataset.id);
                if (confirm("Czy na pewno chcesz usunąć tę talię? Spowoduje to usunięcie wszystkich słówek z nią powiązanych.")) {
                    await deleteDeck(deckId);
                    await renderDecksList();
                }
            });
        });

        if (activeDeckId) {
            await setActiveDeck(activeDeckId);
        }
      }

      async function addDeck() {
        if (!user) {
            alert("Musisz być zalogowany, aby dodać talię.");
            return;
        }
        const name = newDeckNameInput.value.trim();
        if (name) {
          const { data, error } = await supabaseClient
            .from('decks')
            .insert({ name: name, user_id: user.id })
            .select();

          if (error) {
            console.error("Error adding deck:", error);
            alert("Błąd podczas dodawania talii: " + error.message);
          } else {
            console.log("Deck added:", data);
            newDeckNameInput.value = '';
            await renderDecksList();
            activeDeckId = normalizeId(data[0].id);
            await setAppData('activeDeckId', activeDeckId);
            await setActiveDeck(activeDeckId);
            showSection('word-management-section');
          }
        }
      }

      async function updateDeck(deckId, newName) {
          if (!user) return;
          const { error } = await supabaseClient
              .from('decks')
              .update({ name: newName })
              .eq('id', normalizeId(deckId))
              .eq('user_id', user.id);
          if (error) {
              console.error("Error updating deck:", error);
              alert("Błąd podczas aktualizacji talii: " + error.message);
          } else {
              console.log("Deck updated.");
          }
      }

      async function deleteDeck(deckId) {
          if (!user) return;
          const { error } = await supabaseClient
              .from('decks')
              .delete()
              .eq('id', normalizeId(deckId))
              .eq('user_id', user.id);
          if (error) {
              console.error("Error deleting deck:", error);
              alert("Błąd podczas usuwania talii: " + error.message);
          } else {
              console.log("Deck deleted.");
              if (normalizeId(activeDeckId) === normalizeId(deckId)) {
                  activeDeckId = null;
                  await setAppData('activeDeckId', null);
              }
          }
      }

      addDeckBtn.addEventListener('click', addDeck);
      importWordsBtn.addEventListener('click', async () => {
          document.getElementById('image-upload-input').setAttribute('accept', '.json');
          document.getElementById('image-upload-input').click();
          document.getElementById('image-upload-input').onchange = async (e) => {
              const file = e.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = async (event) => {
                  try {
                      const importedWords = JSON.parse(event.target.result);
                      if (!Array.isArray(importedWords) || importedWords.some(w => !w.english || !w.polish)) {
                          alert("Nieprawidłowy format pliku. Oczekiwano tablicy obiektów { english: '...', polish: '...' }.");
                          return;
                      }

                      const wordsToAdd = importedWords.map(word => ({
                          english: word.english,
                          polish: word.polish,
                          example_en: word.example_en || null,
                          example_pl: word.example_pl || null,
                          image: word.image || null
                      }));
                      
                      const result = await saveWords(wordsToAdd, activeDeckId);
                      if (result.success) {
                          alert(`Pomyślnie zaimportowano ${wordsToAdd.length} słówek.`);
                          await loadWordsForActiveDeck();
                          renderWordList();
                      }
                  } catch (parseError) {
                      alert("Błąd podczas parsowania pliku JSON: " + parseError.message);
                  } finally {
                      e.target.value = null;
                      document.getElementById('image-upload-input').setAttribute('accept', 'image/*');
                  }
              };
              reader.readAsText(file);
          };
      });

      // --- Words ---
      async function setActiveDeck(deckId) {
        activeDeckId = normalizeId(deckId);
        await setAppData('activeDeckId', activeDeckId);
        const deck = decks.find(d => normalizeId(d.id) === activeDeckId);
        if (deck) {
          activeDeckNameSpan.textContent = deck.name;
        } else {
          activeDeckNameSpan.textContent = 'Brak talii';
        }
        await loadWordsForActiveDeck();
        renderWordList();
      }

      async function loadWordsForActiveDeck() {
          if (!activeDeckId || !user) {
              words = [];
              return;
          }

          console.log("Syncing words from Supabase for deck:", activeDeckId);
          const { data: cloudWords, error } = await supabaseClient
              .from('words')
              .select('*')
              .eq('deck_id', normalizeId(activeDeckId))
              .eq('user_id', user.id);

          if (error) {
              console.error("Error fetching words from Supabase, trying local fallback:", error);
              // Fallback logic can be more robust, for now just logging
              words = []; // Or try loading from IndexedDB
              return;
          }

          const formattedWords = cloudWords.map(w => ({
              id: normalizeId(w.id),
              deckId: normalizeId(w.deck_id),
              userId: w.user_id,
              english: w.english,
              polish: w.polish,
              example_en: w.example_en,
              example_pl: w.example_pl,
              image: w.image,
              interval: 0, 
              nextReview: getToday().toISOString().split('T')[0],
              easeFactor: 2.5, 
              isLearning: false, 
              learnedDate: null, 
              successCount: 0
          }));
          
          words = formattedWords; // Directly use cloud data as the source of truth

          const { data: progressRecords, error: progressError } = await supabaseClient
              .from('user_word_progress')
              .select('*')
              .eq('user_id', user.id)
              .eq('deck_id', normalizeId(activeDeckId));

          if (progressError) {
              console.error('Error fetching user progress:', progressError);
          } else if (progressRecords) {
              const progressMap = new Map(progressRecords.map(p => [normalizeId(p.word_id), p]));
              words.forEach(word => {
                  if (progressMap.has(normalizeId(word.id))) {
                      const progress = progressMap.get(normalizeId(word.id));
                      word.interval = progress.interval;
                      word.easeFactor = progress.ease_factor;
                      word.nextReview = progress.next_review ? new Date(progress.next_review).toISOString().split('T')[0] : getToday().toISOString().split('T')[0];
                      word.learnedDate = progress.learned_date ? new Date(progress.learned_date).toISOString().split('T')[0] : null;
                      word.successCount = progress.success_count || 0;
                  }
              });
              console.log(`Merged ${progressMap.size} progress records from cloud.`);
          }
      }
      
      async function saveWords(wordsToSave, targetDeckId) {
          if (!user) {
              alert("You must be logged in to save words.");
              return { success: false };
          }

          const supabaseWords = wordsToSave.map(w => ({
              deck_id: normalizeId(targetDeckId), 
              user_id: user.id,
              english: w.english,
              polish: w.polish,
              example_en: w.example_en || null,
              example_pl: w.example_pl || null,
              image: w.image || null
          }));

          const { error } = await supabaseClient.from('words').insert(supabaseWords);
          
          if (error) {
              console.error("Error saving words to Supabase:", error);
              if(error.code === '23505') {
                  alert("One or more words already exist in this deck and were not added again.");
              } else {
                  alert("There was an error saving words to the cloud. Please check the console for details.");
              }
              return { success: false };
          } else {
              console.log("Successfully saved words to Supabase.");
              return { success: true };
          }
      }

      async function updateWord(wordId, updatedFields) {
        if (!user) return;
        const { error } = await supabaseClient
            .from('words')
            .update(updatedFields)
            .eq('id', normalizeId(wordId))
            .eq('user_id', user.id);
        if (error) {
            console.error("Error updating word:", error);
            alert("Błąd podczas aktualizacji słówka: " + error.message);
        } else {
            console.log("Word updated.");
        }
      }

      async function deleteWord(wordId) {
          if (!user) return;
          const { error } = await supabaseClient
              .from('words')
              .delete()
              .eq('id', normalizeId(wordId))
              .eq('user_id', user.id);
          if (error) {
              console.error("Error deleting word:", error);
              alert("Błąd podczas usuwania słówka: " + error.message);
          } else {
              console.log("Word deleted.");
          }
      }

      function renderWordList() {
        wordList.innerHTML = '';
        if (activeDeckId) {
          const activeWords = words.filter(w => normalizeId(w.deckId) === normalizeId(activeDeckId));
          activeWords.forEach(word => {
            const wordElement = document.createElement('div');
            wordElement.className = 'bg-white p-4 rounded-lg shadow-sm flex items-center justify-between';
            wordElement.innerHTML = `
              <div class="flex-grow">
                <span class="text-lg font-medium text-slate-800">${word.english}</span>
                <span class="text-slate-500 ml-2">(${word.polish})</span>
              </div>
              <div class="flex space-x-2">
                <button class="edit-word-btn text-slate-500 hover:text-sky-600" data-id="${word.id}">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                </button>
                <button class="delete-word-btn text-red-500 hover:text-red-600" data-id="${word.id}">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                </button>
              </div>
            `;
            wordList.appendChild(wordElement);
          });
          attachWordEventListeners();
        } else {
          wordList.innerHTML = '<p class="text-slate-500 text-center">Wybierz talię, aby zobaczyć słówka.</p>';
        }
      }

      function attachWordEventListeners() {
          document.querySelectorAll('.edit-word-btn').forEach(el => {
              el.addEventListener('click', async (e) => {
                  const wordId = normalizeId(e.currentTarget.dataset.id);
                  const word = words.find(w => normalizeId(w.id) === wordId);
                  if (word) {
                      openEditWordModal(word);
                  }
              });
          });

          document.querySelectorAll('.delete-word-btn').forEach(el => {
              el.addEventListener('click', async (e) => {
                  const wordId = normalizeId(e.currentTarget.dataset.id);
                  if (confirm("Czy na pewno chcesz usunąć to słówko?")) {
                      await deleteWord(wordId);
                      await loadWordsForActiveDeck();
                      renderWordList();
                  }
              });
          });
      }
      
      // =============================================================
      // POPRAWIONA FUNKCJA addWord
      // =============================================================
      async function addWord() {
        if (!user || !activeDeckId) {
            alert("Musisz być zalogowany i wybrać talię, aby dodać słówko.");
            return;
        }
        const english = englishInput.value.trim();
        const polish = polishInput.value.trim();
        const example_en = exampleEnInput.value.trim() || null;
        const example_pl = examplePlInput.value.trim() || null;
        const image = currentWordImage || null;

        if (!english || !polish) {
            alert("Słówko angielskie i polskie tłumaczenie są wymagane.");
            return;
        }

        const wordsToAdd = [{ english, polish, example_en, example_pl, image }];
        const result = await saveWords(wordsToAdd, activeDeckId);

        if (result.success) {
            englishInput.value = '';
            polishInput.value = '';
            exampleEnInput.value = '';
            examplePlInput.value = '';
            currentWordImage = null;
            wordImagePreview.src = '';
            wordImagePreview.classList.add('hidden');
            removeImageBtn.classList.add('hidden');
            await loadWordsForActiveDeck();
            renderWordList();
        }
      }
      // =============================================================

      addWordBtn.addEventListener('click', addWord);

      // --- Image Upload ---
      addImageBtn.addEventListener('click', () => {
        activeImageTarget = 'word';
        imageUploadInput.click();
      });

      removeImageBtn.addEventListener('click', () => {
        currentWordImage = null;
        wordImagePreview.src = '';
        wordImagePreview.classList.add('hidden');
        removeImageBtn.classList.add('hidden');
      });

      uploadHeaderBtn.addEventListener('click', () => {
          activeImageTarget = 'header';
          headerUploadInput.click();
      });

      uploadGlobalBgBtn.addEventListener('click', () => {
          activeImageTarget = 'global-bg';
          globalBgUploadInput.click();
      });

      uploadStoryBgBtn.addEventListener('click', () => {
          activeImageTarget = 'story-bg';
          storyBgUploadInput.click();
      });

      imageUploadInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file || activeImageTarget !== 'word') return;

        const { publicUrl, error } = await uploadImage(file, 'word-images');
        if (error) {
            alert('Błąd podczas wgrywania obrazka: ' + error.message);
            return;
        }
        currentWordImage = publicUrl;
        wordImagePreview.src = publicUrl;
        wordImagePreview.classList.remove('hidden');
        removeImageBtn.classList.remove('hidden');
        if (activeImageWordId) {
            await updateWord(activeImageWordId, { image: publicUrl });
        }
        event.target.value = null;
      });

      headerUploadInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const { publicUrl, error } = await uploadImage(file, 'app-assets');
        if (error) {
            alert('Błąd podczas wgrywania obrazka nagłówka: ' + error.message);
            return;
        }
        headerImage.src = publicUrl;
        await setAppData('headerImage', publicUrl);
        event.target.value = null;
      });

      globalBgUploadInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const { publicUrl, error } = await uploadImage(file, 'app-assets');
        if (error) {
            alert('Błąd podczas wgrywania globalnego tła: ' + error.message);
            return;
        }
        document.body.style.backgroundImage = `url('${publicUrl}')`;
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundPosition = 'center';
        document.body.style.backgroundAttachment = 'fixed';
        await setAppData('globalBackgroundImage', publicUrl);
        event.target.value = null;
      });

      storyBgUploadInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const { publicUrl, error } = await uploadImage(file, 'story-backgrounds');
        if (error) {
            alert('Błąd podczas wgrywania tła historii: ' + error.message);
            return;
        }
        if (activeStory) {
            const storyContentElement = document.getElementById('story-content');
            storyContentElement.style.backgroundImage = `url('${publicUrl}')`;
            storyContentElement.style.backgroundSize = 'cover';
            storyContentElement.style.backgroundPosition = 'center';
            storyContentElement.style.backgroundAttachment = 'fixed';
            activeStory.backgroundImage = publicUrl;
            await updateStory(activeStory.id, { background_image: publicUrl }); // Corrected field name
            await setAppData(`storyBg_${activeStory.id}`, publicUrl);
        }
        event.target.value = null;
      });

      async function uploadImage(file, bucketName) {
          if (!user) {
              return { error: { message: "Musisz być zalogowany, aby wgrać obrazek." } };
          }
          const fileExtension = file.name.split('.').pop();
          const fileName = `${user.id}/${Date.now()}.${fileExtension}`; // Simplified path
          const { data, error } = await supabaseClient.storage
              .from(bucketName)
              .upload(fileName, file, {
                  cacheControl: '3600',
                  upsert: true
              });
          if (error) {
              console.error("Supabase Storage upload error:", error);
              return { error };
          }
          const { data: publicUrlData } = supabaseClient.storage.from(bucketName).getPublicUrl(fileName);
          return { publicUrl: publicUrlData.publicUrl };
      }

      // --- Modals ---
      function openModal(title, contentHtml, onConfirm) {
        modalTitle.textContent = title;
        modalBody.innerHTML = contentHtml;
        modalContainer.classList.remove('hidden');
        setTimeout(() => {
          modalContainer.classList.remove('opacity-0');
          modalContent.classList.remove('translate-y-4');
        }, 10);
        modalConfirmBtn.onclick = () => {
            onConfirm();
            closeModal();
        };
        modalCancelBtn.onclick = closeModal;
      }

      function closeModal() {
        modalContainer.classList.add('opacity-0');
        modalContent.classList.add('translate-y-4');
        setTimeout(() => modalContainer.classList.add('hidden'), 300);
      }

      function openEditWordModal(word) {
        activeImageWordId = word.id;
        openModal(
          `Edytuj słówko: ${word.english}`,
          `
          <div class="mb-4">
            <label for="edit-english" class="block text-sm font-medium text-slate-700">Angielskie</label>
            <input type="text" id="edit-english" value="${word.english}" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
          </div>
          <div class="mb-4">
            <label for="edit-polish" class="block text-sm font-medium text-slate-700">Polskie</label>
            <input type="text" id="edit-polish" value="${word.polish}" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
          </div>
          <div class="mb-4">
            <label for="edit-example-en" class="block text-sm font-medium text-slate-700">Przykładowe zdanie (ang.)</label>
            <input type="text" id="edit-example-en" value="${word.example_en || ''}" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
          </div>
          <div class="mb-4">
            <label for="edit-example-pl" class="block text-sm font-medium text-slate-700">Przykładowe zdanie (pol.)</label>
            <input type="text" id="edit-example-pl" value="${word.example_pl || ''}" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
          </div>
          <div class="flex items-center space-x-2 mb-4">
            <img id="edit-word-image-preview" src="${word.image || ''}" alt="Podgląd obrazka" class="w-20 h-20 object-cover rounded-lg border border-slate-300 ${word.image ? '' : 'hidden'}">
            <button id="edit-add-image-btn" class="bg-yellow-500 text-white px-4 py-2 rounded-lg hover:bg-yellow-600 transition-colors">Dodaj/Zmień obrazek</button>
            <button id="edit-remove-image-btn" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition-colors ${word.image ? '' : 'hidden'}">Usuń obrazek</button>
          </div>
          `,
          async () => {
            const updatedFields = {
              english: document.getElementById('edit-english').value.trim(),
              polish: document.getElementById('edit-polish').value.trim(),
              example_en: document.getElementById('edit-example-en').value.trim() || null,
              example_pl: document.getElementById('edit-example-pl').value.trim() || null,
              image: document.getElementById('edit-word-image-preview').src.includes('http') ? document.getElementById('edit-word-image-preview').src : null
            };
            if (!updatedFields.english || !updatedFields.polish) {
              alert("Słówko angielskie i polskie tłumaczenie są wymagane.");
              return;
            }
            await updateWord(word.id, updatedFields);
            await loadWordsForActiveDeck();
            renderWordList();
            activeImageWordId = null;
          }
        );
        
        const editAddImageBtn = document.getElementById('edit-add-image-btn');
        const editRemoveImageBtn = document.getElementById('edit-remove-image-btn');
        const editWordImagePreview = document.getElementById('edit-word-image-preview');

        editAddImageBtn.addEventListener('click', () => {
            activeImageTarget = 'word';
            imageUploadInput.onchange = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const { publicUrl, error } = await uploadImage(file, 'word-images');
                if (error) {
                    alert('Błąd podczas wgrywania obrazka: ' + error.message);
                    return;
                }
                editWordImagePreview.src = publicUrl;
                editWordImagePreview.classList.remove('hidden');
                editRemoveImageBtn.classList.remove('hidden');
                event.target.value = null;
                imageUploadInput.onchange = null; // Clear handler
            };
            imageUploadInput.click();
        });

        editRemoveImageBtn.addEventListener('click', () => {
            editWordImagePreview.src = '';
            editWordImagePreview.classList.add('hidden');
            editRemoveImageBtn.classList.add('hidden');
        });
      }

      // --- Review Session ---
      function getToday() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        return today;
      }

      function calculateNextReview(word, difficulty) {
        let interval = word.interval || 0;
        let easeFactor = word.easeFactor || 2.5;
        const today = getToday();

        switch (difficulty) {
          case 'again':
            interval = 0;
            easeFactor = Math.max(1.3, easeFactor - 0.2);
            word.successCount = 0;
            break;
          case 'hard':
            interval = interval === 0 ? 10 / 60 / 24 : interval / 2;
            easeFactor = Math.max(1.3, easeFactor - 0.15);
            word.successCount = 0;
            break;
          case 'good':
            word.successCount = (word.successCount || 0) + 1;
            if (interval === 0) {
              interval = 1;
            } else if (interval === 1) {
              interval = 6;
            } else {
              interval *= easeFactor;
            }
            easeFactor = Math.min(2.5, easeFactor + 0.1);
            break;
        }

        const nextReviewDate = new Date(today);
        nextReviewDate.setDate(today.getDate() + Math.ceil(interval));

        return {
          interval: interval,
          easeFactor: parseFloat(easeFactor.toFixed(2)),
          nextReview: nextReviewDate.toISOString().split('T')[0],
          learnedDate: interval >= 21 ? today.toISOString().split('T')[0] : word.learnedDate
        };
      }

      function getNextIntervalText(word, difficulty) {
          let tempWord = { ...word };
          const { interval } = calculateNextReview(tempWord, difficulty);
          if (interval === 0) return '1m';
          if (interval < 1) return `${Math.round(interval * 24 * 60)}m`;
          if (interval < 30) return `${Math.ceil(interval)}d`;
          if (interval < 365) return `${Math.round(interval / 30)}mo`;
          return `${Math.round(interval / 365)}y`;
      }
      
      async function loadReviewQueue() {
          if (!user || !activeDeckId) {
              reviewQueue = [];
              return;
          }

          const today = getToday();
          const todayISO = today.toISOString().split('T')[0];

          // Re-sync progress to ensure it's up to date before review
          await loadWordsForActiveDeck(); 

          let wordsForReview = [];
          let newWords = [];

          const allWordsInDeck = words.filter(w => normalizeId(w.deckId) === normalizeId(activeDeckId));

          for (const word of allWordsInDeck) {
              const nextReviewDate = new Date(word.nextReview);
              nextReviewDate.setHours(0, 0, 0, 0);

              if (word.interval > 0) { // Has progress
                  if (REVIEW_IGNORE_DATE || nextReviewDate <= today) {
                      wordsForReview.push({ ...word, isNew: false });
                  }
              } else { // Is a new word
                  newWords.push({ ...word, isNew: true });
              }
          }

          if (DAILY_NEW_LIMIT !== Infinity) {
              newWords = newWords.slice(0, DAILY_NEW_LIMIT);
          }

          reviewQueue = [...wordsForReview, ...newWords].sort(() => Math.random() - 0.5);
          currentCardIndex = 0;
          console.log(`Review queue loaded: ${reviewQueue.length} words. (${wordsForReview.length} for review, ${newWords.length} new)`);
          
          if (reviewQueue.length > 0) {
              currentCard = reviewQueue[currentCardIndex];
              renderCard();
              difficultyButtons.classList.add('hidden');
              reviewStatus.classList.remove('hidden');
              finishReviewBtn.classList.remove('hidden');
              updateReviewStatus();
          } else {
              displayReviewFinishMessage();
          }
      }

      function startReviewSession() {
          if (!activeDeckId) {
              alert("Wybierz talię, aby rozpocząć naukę!");
              showSection('decks-section');
              return;
          }
          currentCardIndex = 0;
          isCardFlipped = false;
          loadReviewQueue();
          showSection('review-section');
          document.getElementById('review-controls').classList.add('hidden');
          flashcard.classList.remove('is-flipped');
          cardBack.classList.add('hidden');
          difficultyButtons.classList.add('hidden');
      }

      function displayReviewFinishMessage() {
          cardEnglish.textContent = 'Brawo!';
          cardPolish.textContent = '';
          cardExampleEn.textContent = 'Wszystkie słówka na dziś powtórzone!';
          cardExamplePl.textContent = '';
          cardImage.classList.add('hidden');
          speakEnglishBtn.classList.add('hidden');
          speakPolishBtn.classList.add('hidden');
          reviewStatus.textContent = 'Koniec sesji!';
          difficultyButtons.classList.add('hidden');
          finishReviewBtn.classList.remove('hidden');
          flashcard.classList.remove('is-flipped');
          cardFront.classList.remove('hidden');
          cardBack.classList.add('hidden');
          document.getElementById('review-controls').classList.remove('hidden');
          document.getElementById('start-review-btn').classList.remove('hidden');
      }

      function renderCard() {
          if (!currentCard) {
              displayReviewFinishMessage();
              return;
          }
          cardEnglish.textContent = currentCard.english;
          cardExampleEn.textContent = currentCard.example_en || '';
          cardExampleEn.classList.toggle('hidden', !currentCard.example_en);
          
          if (currentCard.image) {
              cardImage.src = currentCard.image;
              cardImage.classList.remove('hidden');
          } else {
              cardImage.classList.add('hidden');
              cardImage.src = '';
          }

          cardPolish.textContent = currentCard.polish;
          cardExamplePl.textContent = currentCard.example_pl || '';
          cardExamplePl.classList.toggle('hidden', !currentCard.example_pl);

          isCardFlipped = false;
          flashcard.classList.remove('is-flipped');
          cardFront.classList.remove('hidden');
          cardBack.classList.add('hidden');
          difficultyButtons.classList.add('hidden');
          speakEnglishBtn.classList.remove('hidden');
          speakPolishBtn.classList.add('hidden');

          againIntervalSpan.textContent = getNextIntervalText(currentCard, 'again');
          hardIntervalSpan.textContent = getNextIntervalText(currentCard, 'hard');
          goodIntervalSpan.textContent = getNextIntervalText(currentCard, 'good');

          updateReviewStatus();
      }

      flashcard.addEventListener('click', () => {
        if (!currentCard) return;
        isCardFlipped = !isCardFlipped;
        flashcard.classList.toggle('is-flipped', isCardFlipped);
        
        // This logic is simplified with a timeout to handle animation correctly
        setTimeout(() => {
          if (isCardFlipped) {
            cardFront.classList.add('hidden');
            cardBack.classList.remove('hidden');
            difficultyButtons.classList.remove('hidden');
            speakEnglishBtn.classList.add('hidden');
            speakPolishBtn.classList.remove('hidden');
          } else {
            cardFront.classList.remove('hidden');
            cardBack.classList.add('hidden');
            difficultyButtons.classList.add('hidden');
            speakEnglishBtn.classList.remove('hidden');
            speakPolishBtn.classList.add('hidden');
          }
        }, 250); // Delay should be less than CSS transition time
      });

      async function processAnswer(difficulty) {
        if (!currentCard) return;

        const { interval, easeFactor, nextReview, learnedDate } = calculateNextReview(currentCard, difficulty);

        currentCard.interval = interval;
        currentCard.ease_factor = easeFactor;
        currentCard.next_review = nextReview;
        currentCard.learned_date = learnedDate;
        
        if (user) {
            const { error } = await supabaseClient
                .from('user_word_progress')
                .upsert({
                    user_id: user.id,
                    word_id: normalizeId(currentCard.id),
                    deck_id: normalizeId(activeDeckId),
                    interval: currentCard.interval,
                    ease_factor: currentCard.ease_factor,
                    next_review: currentCard.next_review,
                    learned_date: currentCard.learned_date,
                    success_count: currentCard.success_count,
                    last_updated: new Date().toISOString()
                }, { onConflict: 'user_id, word_id' });

            if (error) {
                console.error("Error saving word progress to Supabase:", error);
                alert("Błąd podczas zapisywania postępu. Spróbuj ponownie.");
            } else {
                console.log("Word progress saved for word:", currentCard.english);
            }
        }
        
        currentCardIndex++;
        if (currentCardIndex < reviewQueue.length) {
          currentCard = reviewQueue[currentCardIndex];
          renderCard();
        } else {
          currentCard = null;
          displayReviewFinishMessage();
        }
      }

      againBtn.addEventListener('click', () => processAnswer('again'));
      hardBtn.addEventListener('click', () => processAnswer('hard'));
      goodBtn.addEventListener('click', () => processAnswer('good'));
      startReviewBtn.addEventListener('click', startReviewSession);
      finishReviewBtn.addEventListener('click', () => {
          showSection('decks-section');
          document.getElementById('review-controls').classList.remove('hidden');
      });

      function updateReviewStatus() {
        if (currentCard) {
            reviewStatus.textContent = `Słówka: ${currentCardIndex + 1} / ${reviewQueue.length}`;
            reviewStatus.classList.remove('hidden');
        } else {
            reviewStatus.classList.add('hidden');
        }
      }

      // --- Text-to-Speech ---
      const speechSynthesisSupported = 'speechSynthesis' in window;
      let speechUtterance = speechSynthesisSupported ? new SpeechSynthesisUtterance() : null;

      speakEnglishBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (speechSynthesisSupported && currentCard && currentCard.english) {
          speechUtterance.text = currentCard.english;
          speechUtterance.lang = ENGLISH_ACCENT;
          speechSynthesis.speak(speechUtterance);
        }
      });

      speakPolishBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (speechSynthesisSupported && currentCard && currentCard.polish) {
          speechUtterance.text = currentCard.polish;
          speechUtterance.lang = 'pl-PL';
          speechSynthesis.speak(speechUtterance);
        }
      });

      // --- Learned Words ---
      async function renderLearnedWords() {
          learnedWordsList.innerHTML = '';
          if (!user) {
              learnedWordsList.innerHTML = '<p class="text-slate-500 text-center">Zaloguj się, aby zobaczyć opanowane słówka.</p>';
              return;
          }

          const { data: progressRecords, error: progressError } = await supabaseClient
              .from('user_word_progress')
              .select('word_id, learned_date')
              .eq('user_id', user.id)
              .not('learned_date', 'is', null);

          if (progressError) {
              console.error("Error fetching learned words progress:", progressError);
              learnedWordsList.innerHTML = '<p class="text-red-500 text-center">Błąd podczas ładowania opanowanych słówek.</p>';
              return;
          }

          if (progressRecords.length === 0) {
              learnedWordsList.innerHTML = '<p class="text-slate-500 text-center">Jeszcze nie opanowałeś żadnych słówek. Kontynuuj naukę!</p>';
              return;
          }

          const learnedWordIds = progressRecords.map(p => normalizeId(p.word_id));
          
          const { data: learnedWordsData, error: wordsError } = await supabaseClient
              .from('words')
              .select('id, english, polish, deck_id')
              .in('id', learnedWordIds)
              .eq('user_id', user.id);

          if (wordsError) {
              console.error("Error fetching details for learned words:", wordsError);
              learnedWordsList.innerHTML = '<p class="text-red-500 text-center">Błąd podczas ładowania szczegółów opanowanych słówek.</p>';
              return;
          }

          const wordsMap = new Map(learnedWordsData.map(w => [normalizeId(w.id), w]));
          const decksMap = new Map(decks.map(d => [normalizeId(d.id), d.name]));

          progressRecords.forEach(progress => {
              const word = wordsMap.get(normalizeId(progress.word_id));
              if (word) {
                  const deckName = decksMap.get(normalizeId(word.deck_id)) || 'Nieznana talia';
                  const learnedDate = progress.learned_date ? new Date(progress.learned_date).toLocaleDateString() : 'N/A';
                  const wordElement = document.createElement('div');
                  wordElement.className = 'bg-white p-4 rounded-lg shadow-sm flex items-center justify-between';
                  wordElement.innerHTML = `
                      <div>
                          <p class="text-lg font-medium text-sky-700">${word.english} - ${word.polish}</p>
                          <p class="text-sm text-slate-500">Talia: ${deckName}, Opanowano: ${learnedDate}</p>
                      </div>
                  `;
                  learnedWordsList.appendChild(wordElement);
              }
          });
      }

      document.getElementById('show-learned-words-btn').addEventListener('click', async () => {
          showSection('learned-words-section');
          await renderLearnedWords();
      });

      // --- Stats ---
      async function renderStats() {
          if (!user) {
              totalWordsCount.textContent = '0';
              learnedWordsCount.textContent = '0';
              toReviewCount.textContent = '0';
              newWordsTodayCount.textContent = '0';
              if (chartInstance) chartInstance.destroy();
              return;
          }
          
          const todayISO = getToday().toISOString().split('T')[0];

          // Using Promise.all for parallel fetching
          const [totalWordsRes, learnedWordsRes, reviewWordsRes, newWordsRes] = await Promise.all([
              supabaseClient.from('words').select('id', { count: 'exact' }).eq('user_id', user.id),
              supabaseClient.from('user_word_progress').select('id', { count: 'exact' }).eq('user_id', user.id).not('learned_date', 'is', null),
              supabaseClient.from('user_word_progress').select('id', { count: 'exact' }).eq('user_id', user.id).lte('next_review', todayISO),
              supabaseClient.from('user_word_progress').select('id', { count: 'exact' }).eq('user_id', user.id).eq('interval', 0).gte('last_updated', todayISO)
          ]);

          totalWordsCount.textContent = totalWordsRes.count || 0;
          learnedWordsCount.textContent = learnedWordsRes.count || 0;
          toReviewCount.textContent = reviewWordsRes.count || 0;
          newWordsTodayCount.textContent = newWordsRes.count || 0;

          // Chart data (for the last 7 days)
          const labels = [];
          const dataPromises = [];
          for (let i = 6; i >= 0; i--) {
              const date = new Date();
              date.setDate(date.getDate() - i);
              date.setHours(0,0,0,0);
              const dateStartISO = date.toISOString();
              const dateEndISO = new Date(date.getTime() + 24 * 60 * 60 * 1000).toISOString();
              labels.push(date.toLocaleDateString('pl-PL', { weekday: 'short', day: 'numeric' }));
              
              dataPromises.push(
                  supabaseClient
                      .from('user_word_progress')
                      .select('id', { count: 'exact' })
                      .eq('user_id', user.id)
                      .gte('last_updated', dateStartISO)
                      .lt('last_updated', dateEndISO)
                      .gt('interval', 0)
              );
          }

          const dailyCounts = await Promise.all(dataPromises);
          const data = dailyCounts.map(res => res.count || 0);

          if (chartInstance) {
              chartInstance.destroy();
          }
          chartInstance = new Chart(progressChartCtx, {
              type: 'bar',
              data: {
                  labels: labels,
                  datasets: [{
                      label: 'Słówka powtórzone',
                      data: data,
                      backgroundColor: 'rgba(56, 189, 248, 0.6)',
                      borderColor: 'rgba(56, 189, 248, 1)',
                      borderWidth: 1
                  }]
              },
              options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  scales: { y: { beginAtZero: true, title: { display: true, text: 'Liczba słówek' } } },
                  plugins: { legend: { display: false } }
              }
          });
      }

      document.getElementById('show-stats-btn').addEventListener('click', async () => {
          showSection('stats-section');
          await renderStats();
      });
      
      // --- Stories ---
      async function getCloudStories() {
          if (!user) return [];
          const { data, error } = await supabaseClient
              .from('stories')
              .select('*')
              .eq('user_id', user.id)
              .order('title', { ascending: true });
          if (error) {
              console.error("Error fetching stories from Supabase:", error);
              return [];
          }
          return data.map(s => ({ 
              id: normalizeId(s.id), 
              user_id: s.user_id, 
              title: s.title, 
              content: s.content, 
              backgroundImage: s.background_image 
          }));
      }

      async function renderStoriesList() {
          storiesList.innerHTML = '';
          if (user) {
              stories = await getCloudStories();
          } else {
              stories = [];
              showSection('auth-section');
              return;
          }

          if (stories.length === 0) {
              storiesList.innerHTML = '<p class="text-slate-500 text-center">Brak historii. Dodaj nową historię!</p>';
              return;
          }

          for (const story of stories) {
              const storyElement = document.createElement('div');
              storyElement.className = 'bg-white p-4 rounded-lg shadow-sm flex items-center justify-between';
              storyElement.innerHTML = `
                  <span class="text-lg font-medium text-sky-700 cursor-pointer story-title" data-id="${story.id}">${story.title}</span>
                  <div class="flex space-x-2">
                      <button class="edit-story-btn text-slate-500 hover:text-sky-600" data-id="${story.id}">
                          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                      </button>
                      <button class="delete-story-btn text-red-500 hover:text-red-600" data-id="${story.id}">
                          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                      </button>
                  </div>
              `;
              storiesList.appendChild(storyElement);
          }

          document.querySelectorAll('.story-title').forEach(el => {
              el.addEventListener('click', async (e) => {
                  const storyId = normalizeId(e.target.dataset.id);
                  await openStory(storyId);
              });
          });

          document.querySelectorAll('.edit-story-btn').forEach(el => {
              el.addEventListener('click', async (e) => {
                  e.stopPropagation();
                  const storyId = normalizeId(e.currentTarget.dataset.id);
                  const story = stories.find(s => normalizeId(s.id) === storyId);
                  if (story) {
                      openEditStoryModal(story);
                  }
              });
          });

          document.querySelectorAll('.delete-story-btn').forEach(el => {
              el.addEventListener('click', async (e) => {
                  e.stopPropagation();
                  const storyId = normalizeId(e.currentTarget.dataset.id);
                  if (confirm("Czy na pewno chcesz usunąć tę historię?")) {
                      await deleteStory(storyId);
                      await renderStoriesList();
                  }
              });
          });
      }

      async function addStory() {
          if (!user) {
              alert("Musisz być zalogowany, aby dodać historię.");
              return;
          }
          const title = newStoryTitleInput.value.trim();
          if (title) {
              const { data, error } = await supabaseClient
                  .from('stories')
                  .insert({ title: title, user_id: user.id, content: '' })
                  .select();

              if (error) {
                  console.error("Error adding story:", error);
                  alert("Błąd podczas dodawania historii: " + error.message);
              } else {
                  console.log("Story added:", data);
                  newStoryTitleInput.value = '';
                  await renderStoriesList();
                  await openStory(normalizeId(data[0].id));
              }
          }
      }

      async function updateStory(storyId, updatedFields) {
          if (!user) return;
          const { error } = await supabaseClient
              .from('stories')
              .update(updatedFields)
              .eq('id', normalizeId(storyId))
              .eq('user_id', user.id);
          if (error) {
              console.error("Error updating story:", error);
              alert("Błąd podczas aktualizacji historii: " + error.message);
          } else {
              console.log("Story updated.");
          }
      }

      async function deleteStory(storyId) {
          if (!user) return;
          const { error } = await supabaseClient
              .from('stories')
              .delete()
              .eq('id', normalizeId(storyId))
              .eq('user_id', user.id);
          if (error) {
              console.error("Error deleting story:", error);
              alert("Błąd podczas usuwania historii: " + error.message);
          } else {
              console.log("Story deleted.");
              const store = getTransaction('story-progress');
              await idbRequest(store.delete([normalizeId(storyId), user.id]));
          }
      }

      addStoryBtn.addEventListener('click', addStory);
      importStoryFileBtn.addEventListener('click', () => {
          storyUploadInput.click();
      });

      storyUploadInput.addEventListener('change', async (event) => {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = async (e) => {
              const content = e.target.result;
              const title = file.name.replace(/\.[^/.]+$/, "");
              if (!user) {
                  alert("Musisz być zalogowany, aby importować historie.");
                  return;
              }
              const { data, error } = await supabaseClient
                  .from('stories')
                  .insert({ title: title, user_id: user.id, content: content })
                  .select();

              if (error) {
                  console.error("Error importing story:", error);
                  alert("Błąd podczas importowania historii: " + error.message);
              } else {
                  console.log("Story imported:", data);
                  await renderStoriesList();
                  await openStory(normalizeId(data[0].id));
              }
              storyUploadInput.value = null; // Reset input file
          };
          reader.readAsText(file);
      });

      function openEditStoryModal(story) {
          openModal(
              `Edytuj historię: ${story.title}`,
              `
              <div class="mb-4">
                  <label for="edit-story-title" class="block text-sm font-medium text-slate-700">Tytuł</label>
                  <input type="text" id="edit-story-title" value="${story.title}" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500">
              </div>
              <div class="mb-4">
                  <label for="edit-story-content" class="block text-sm font-medium text-slate-700">Treść</label>
                  <textarea id="edit-story-content" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500" rows="10">${story.content}</textarea>
              </div>
              `,
              async () => {
                  const updatedFields = {
                      title: document.getElementById('edit-story-title').value.trim(),
                      content: document.getElementById('edit-story-content').value.trim(),
                  };
                  if (!updatedFields.title) {
                      alert("Tytuł historii jest wymagany.");
                      return;
                  }
                  await updateStory(story.id, updatedFields);
                  await renderStoriesList();
              }
          );
      }

      async function openStory(storyId) {
          const story = stories.find(s => normalizeId(s.id) === normalizeId(storyId));
          if (!story) {
              alert("Historia nie znaleziona.");
              return;
          }
          activeStory = story;
          storyViewerTitle.textContent = activeStory.title;
          showSection('story-viewer-section');

          const storedBg = await getAppData(`storyBg_${activeStory.id}`);
          const bgUrl = activeStory.backgroundImage || storedBg;
          if (bgUrl) {
              storyContentDiv.style.backgroundImage = `url('${bgUrl}')`;
              storyContentDiv.style.backgroundSize = 'cover';
              storyContentDiv.style.backgroundPosition = 'center';
              storyContentDiv.style.backgroundAttachment = 'fixed';
          } else {
              storyContentDiv.style.backgroundImage = 'none';
          }

          const progressKey = [normalizeId(activeStory.id), user.id];
          const storedProgress = await idbRequest(getTransaction('story-progress', 'readonly').get(progressKey));
          currentStoryParagraphIndex = storedProgress ? storedProgress.last_read_paragraph_index : 0;
          renderStoryContent();
      }
      
      function renderStoryContent() {
          if (!activeStory) return;

          storyContentDiv.innerHTML = '';
          const paragraphs = activeStory.content.split('\n').filter(p => p.trim() !== '');

          paragraphs.forEach((paragraphText, index) => {
              const p = document.createElement('p');
              p.className = 'mb-4';
              p.textContent = paragraphText;
              if (index < currentStoryParagraphIndex) {
                  p.classList.add('text-slate-400');
              }
              storyContentDiv.appendChild(p);
          });
          
          if (currentStoryParagraphIndex > 0 && storyContentDiv.children[currentStoryParagraphIndex]) {
              storyContentDiv.children[currentStoryParagraphIndex].scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
      }

      storyContentDiv.addEventListener('scroll', async () => {
          if (!activeStory || !user) return;
          const paragraphs = storyContentDiv.children;
          let newProgressIndex = 0;

          for (let i = 0; i < paragraphs.length; i++) {
              const rect = paragraphs[i].getBoundingClientRect();
              if (rect.top < storyContentDiv.clientHeight / 2) {
                  newProgressIndex = i;
              }
          }
          
          if (newProgressIndex !== currentStoryParagraphIndex) {
              currentStoryParagraphIndex = newProgressIndex;
              const progressKey = [normalizeId(activeStory.id), user.id];
              const store = getTransaction('story-progress');
              await idbRequest(store.put({ story_id: normalizeId(activeStory.id), user_id: user.id, last_read_paragraph_index: currentStoryParagraphIndex }));
              
              // No need to re-render everything, just update classes
              for (let i = 0; i < paragraphs.length; i++) {
                paragraphs[i].classList.toggle('text-slate-400', i < currentStoryParagraphIndex);
              }
          }
      });

      // --- Initialization ---
      async function init() {
        console.log("Initializing app...");
        const { data: { user: currentUser } } = await supabaseClient.auth.getUser();
        user = currentUser;

        await loadCustomAssets();

        if (user) {
          console.log("User logged in:", user.email);
          updateAuthUI();
          await renderDecksList();
          await renderStoriesList();
          
          if (activeDeckId) {
            showSection('word-management-section');
          } else {
            showSection('decks-section');
          }
        } else {
          console.log("User not logged in.");
          showSection('auth-section');
        }
      }

      async function loadCustomAssets() {
          const headerImageUrl = await getAppData('headerImage');
          if (headerImageUrl) {
              headerImage.src = headerImageUrl;
          }

          const globalBgImageUrl = await getAppData('globalBackgroundImage');
          if (globalBgImageUrl) {
              document.body.style.backgroundImage = `url('${globalBgImageUrl}')`;
              document.body.style.backgroundSize = 'cover';
              document.body.style.backgroundPosition = 'center';
              document.body.style.backgroundAttachment = 'fixed';
          }
      }

    }); // <-- KONIEC GŁÓWNEGO BLOKU 'DOMContentLoaded'
  </script>
</body>
</html>